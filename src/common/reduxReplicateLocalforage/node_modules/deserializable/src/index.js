// based on http://www.json.org/js.html

const source = typeof window !== 'undefined' ? window : global;
const ignorePropertyName = /^webkit/i;

RegExp.prototype.toJSON = RegExp.prototype.toString;
RegExp.fromJSON = value => {
  const lastSlash = value.lastIndexOf('/');
  return new RegExp(value.slice(1, lastSlash), value.slice(lastSlash + 1));
};

export const fixedTypes =  {
  Map: {
    toJSON: value => [ ...value ],
    fromJSON: value => new Map(value)
  },
  Set: {
    toJSON: value => [ ...value ],
    fromJSON: value => new Set(value)
  }
};

export const ignoredTypes = {
  Array: true,
  Boolean: true,
  Null: true,
  Number: true,
  Object: true,
  String: true
};

export const getType = (value, key) => {
  let type = null;

  if (value && typeof value.toJSON === 'function') {
    type = Object.prototype.toString.call(value).slice(8, -1);

    if (ignoredTypes[type]) {
      type = null;
    }
  }

  return type;
};

// for some reason the replacer gets called after toJSON
// see https://github.com/douglascrockford/JSON-js/blob/c98948ae1944a28e2e8ebc3717894e580aeaaa05/json2.js#L252-L262
// so instead of using a replacer,
// we have to do this monkey patch nonsense to efficiently get the type
let stringifying = false;

export const patch = (key, fn) => {
  const fixed = fixedTypes[key];
  const toJSON = typeof fn === 'function'
    && fn.prototype
    && fn.prototype.toJSON;

  if (fixed && fixed.toJSON) {
    fn.prototype.toJSON = function() {
      if (stringifying) {
        return {
          __type__: key,
          __value__: fixed.toJSON(this)
        };
      }

      return typeof toJSON === 'function'
        ? toJSON.apply(this, arguments)
        : this;
    };
  } else if (typeof toJSON === 'function') {
    fn.prototype.toJSON = function() {
      const type = stringifying && getType(this);
      const value = toJSON.apply(this, arguments);

      if (type) {
        return {
          __type__: type,
          __value__: value
        };
      }

      return value;
    };
  }
};

export const patchAll = (obj = source, ignore = ignorePropertyName) => {
  for (let key of Object.getOwnPropertyNames(obj)) {
    if (!ignore.test(key)) {
      patch(key, obj[key]);
    }
  }
};

export const reviver = (key, value) => {
  const type = value && value.__value__ && value.__type__;
  const construct = type && (fixedTypes[type] || source[type]);

  if (construct && construct.fromJSON) {
    return construct.fromJSON(value.__value__);
  } else if (typeof construct === 'function') {
    return new construct(value.__value__);
  }

  return value;
};

export const stringify = (value, space) => {
  let stringified;

  stringifying = true;
  try {
    stringified = JSON.stringify(value, null, space);
    stringifying = false;
  } catch(error) {
    stringifying = false;
    throw new Error(error);
  }

  return stringified;
};

export const parse = value => (
  JSON.parse(value, reviver)
);

patchAll();

if (typeof Map !== 'undefined' && Map !== source.Map) {
  patch('Map', Map);
  patch('Set', Set);
}

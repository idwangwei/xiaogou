(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Unserializable"] = factory();
	else
		root["Unserializable"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// based on http://www.json.org/js.html

	var source = typeof window !== 'undefined' ? window : global;
	var ignorePropertyName = /^webkit/i;

	RegExp.prototype.toJSON = RegExp.prototype.toString;
	RegExp.fromJSON = function (value) {
	  var lastSlash = value.lastIndexOf('/');
	  return new RegExp(value.slice(1, lastSlash), value.slice(lastSlash + 1));
	};

	var fixedTypes = exports.fixedTypes = {
	  Map: {
	    toJSON: function toJSON(value) {
	      return [].concat(_toConsumableArray(value));
	    },
	    fromJSON: function fromJSON(value) {
	      return new Map(value);
	    }
	  },
	  Set: {
	    toJSON: function toJSON(value) {
	      return [].concat(_toConsumableArray(value));
	    },
	    fromJSON: function fromJSON(value) {
	      return new Set(value);
	    }
	  }
	};

	var ignoredTypes = exports.ignoredTypes = {
	  Array: true,
	  Boolean: true,
	  Null: true,
	  Number: true,
	  Object: true,
	  String: true
	};

	var getType = exports.getType = function getType(value, key) {
	  var type = null;

	  if (value && typeof value.toJSON === 'function') {
	    type = Object.prototype.toString.call(value).slice(8, -1);

	    if (ignoredTypes[type]) {
	      type = null;
	    }
	  }

	  return type;
	};

	// for some reason the replacer gets called after toJSON
	// see https://github.com/douglascrockford/JSON-js/blob/c98948ae1944a28e2e8ebc3717894e580aeaaa05/json2.js#L252-L262
	// so instead of using a replacer,
	// we have to do this monkey patch nonsense to efficiently get the type
	var stringifying = false;

	var patch = exports.patch = function patch(key, fn) {
	  var fixed = fixedTypes[key];
	  var toJSON = typeof fn === 'function' && fn.prototype && fn.prototype.toJSON;

	  if (fixed && fixed.toJSON) {
	    fn.prototype.toJSON = function () {
	      if (stringifying) {
	        return {
	          __type__: key,
	          __value__: fixed.toJSON(this)
	        };
	      }

	      return typeof toJSON === 'function' ? toJSON.apply(this, arguments) : this;
	    };
	  } else if (typeof toJSON === 'function') {
	    fn.prototype.toJSON = function () {
	      var type = stringifying && getType(this);
	      var value = toJSON.apply(this, arguments);

	      if (type) {
	        return {
	          __type__: type,
	          __value__: value
	        };
	      }

	      return value;
	    };
	  }
	};

	var patchAll = exports.patchAll = function patchAll() {
	  var obj = arguments.length <= 0 || arguments[0] === undefined ? source : arguments[0];
	  var ignore = arguments.length <= 1 || arguments[1] === undefined ? ignorePropertyName : arguments[1];
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = Object.getOwnPropertyNames(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var key = _step.value;

	      if (!ignore.test(key)) {
	        patch(key, obj[key]);
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	};

	var reviver = exports.reviver = function reviver(key, value) {
	  var type = value && value.__value__ && value.__type__;
	  var construct = type && (fixedTypes[type] || source[type]);

	  if (construct && construct.fromJSON) {
	    return construct.fromJSON(value.__value__);
	  } else if (typeof construct === 'function') {
	    return new construct(value.__value__);
	  }

	  return value;
	};

	var stringify = exports.stringify = function stringify(value, space) {
	  var stringified = void 0;

	  stringifying = true;
	  try {
	    stringified = JSON.stringify(value, null, space);
	    stringifying = false;
	  } catch (error) {
	    stringifying = false;
	    throw new Error(error);
	  }

	  return stringified;
	};

	var parse = exports.parse = function parse(value) {
	  return JSON.parse(value, reviver);
	};

	patchAll();

	if (typeof Map !== 'undefined' && Map !== source.Map) {
	  patch('Map', Map);
	  patch('Set', Set);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }
/******/ ])
});
;
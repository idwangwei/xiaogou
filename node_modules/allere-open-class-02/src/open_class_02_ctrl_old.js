/**
 * Created by WangLu on 2017/4/1.
 */
import ruler from '../images/ruler.png';
import triangle from '../images/triangle.png';
import btnPlay from '../images/btn_play.png';
import square1 from '../images/square1.png';
import square2 from '../images/square2.png';
import rectangle1 from '../images/rectangle1.png';
import rectangle2 from '../images/rectangle2.png';


/*
 let ruler ='images/ruler.png';
 let triangle ='images/triangle.png';
 let btnPlay ='images/btn_play.png';
 let square1 ='images/square1.png';
 let square2 ='images/square2.png';
 let rectangle1 ='images/rectangle1.png';
 let rectangle2 ='images/rectangle2.png';
 */

class OpenClass02Ctrl {
    constructor($scope, recordPlayer) {
        this.$scope = $scope;
        this.recordPlayer = recordPlayer;
        this.initData();
    }

    initData() {
        this.$scope.textContent = {
            expr: '',
            inputBoxUUID: ''
        };
        this.dragActionArr = [];
        this.startPostion = {};
        this.oneAaction = {};
        this.oneAaction.path = [];
        this.hasAdsorbFlag = false;
        this.hasInAdsorbArea = false; //是否已经进入过吸附区域
        this.oldInAdsorbArea = null; //发生吸附时的区域
        this.showWordSpr = null;

        this.DATA = {
            DEGREE: Math.PI / 2,
            RULER: "ruler",
            TRIANGLE: "triangle",
            CANVAS_WIDTH: 500,
            CANVAS_HEIGHT: 500,
            SCALE: {
                RULER: 0.8,
                BIG_RULER: 1.2,
            },
            /*  CANVAS_BG_COLOR: "0x1099bb",*/
            CANVAS_BG_COLOR: "0xfafad2",
            ACTION: {
                MOVE: 'move',
                ROTATE: 'rotate',
            },
            SHAPE: {
                SQU: "正方形",
                RECT: '长方形'
            }
        };
    };

    initStage() {
        this.app = new PIXI.Application(this.DATA.CANVAS_WIDTH, this.DATA.CANVAS_HEIGHT, {backgroundColor: this.DATA.CANVAS_BG_COLOR});
        this.body.appendChild(this.app.view);

        this.shape = this.createSprite(this.shapeSrc, this.app.renderer.width / 2, this.app.renderer.height / 2);
        this.shape.alpha = 1;
        this.ruler = this.createSprite(ruler, this.app.renderer.width / 2, this.app.renderer.height / 4, 0.8);
        this.ruler.shapeName = this.DATA.RULER;
        this.triangle = this.createSprite(triangle, this.app.renderer.width / 2, this.app.renderer.height / 1.2, this.DATA.SCALE.RULER);
        this.triangle.shapeName = this.DATA.TRIANGLE;
        this.btnPlay = this.createSprite(btnPlay, this.app.renderer.width / 8, this.app.renderer.height - 50);

        this.bigRuler = this.createSprite(ruler, this.app.renderer.width / 2, this.app.renderer.height / 6, this.DATA.SCALE.BIG_RULER); //放大的尺子
        //this.addRulerMask();
        this.bigRuler.alpha = 0;
        this.pathData = {
            rulerPosition: [this.app.renderer.width / 2, this.app.renderer.height / 4],
            trianglePosition: [this.app.renderer.width / 2, this.app.renderer.height / 1.2],
            config: this.dragActionArr,
        };
        this.$scope.textContent.inputBoxUUID = this.$scope.inputBoxUUID;
        this.updateStage();
         if (this.$scope.showType == 'doQuestion') {
         this.initListenerEvent(this.ruler);
         this.initListenerEvent(this.triangle);
         } else {
         this.initPlayEvent();
         }
       /* this.initListenerEvent(this.ruler);
        this.initListenerEvent(this.triangle);
        this.btnPlay.alpha = 1;
        this.initPlayEvent();*/
    }

    createSprite(img, x, y, scale) {
        var player = new PIXI.Sprite.fromImage(img);
        // 将中心点定在角色图片的中心
        player.anchor.set(0.5);
        player.position.set(x, y);
        player.scale.x = scale || 1;
        player.scale.y = scale || 1;
        player.alpha = 0;
        player.interactive = true;
        player.buttonMode = true;
        // 将玩家精灵加入到舞台上
        this.app.stage.addChild(player);
        return player;
    };

    dragStart(data) {
        if (this.bigRuler) {
            //this.bigRuler.alpha = 0;
        }
        if (this.showWordSpr) {
            this.showWordSpr.alpha = 0;
            this.showWordSpr = null;
        }

        data.data.originalEvent.preventDefault();
        if (data.data.originalEvent.stopPropagation) {
            data.data.originalEvent.stopPropagation();
        }
        data.data.originalEvent.cancelBubble = true;

        let currentTarget = data.currentTarget;
        currentTarget.data = data;
        currentTarget.alpha = 0.5;
        currentTarget.dragging = true;
        currentTarget.clicked = true;
        this.startPostion = {x: data.data.global.x, y: data.data.global.y};

        this.oneAaction = {};
        this.oneAaction.path = [];
        this.oneAaction.target = currentTarget.shapeName;
        if (!this.currentShape || this.currentShape && !this.currentShape.name) {
            this.initShape();
        }
        if (currentTarget.shapeName == this.DATA.RULER) {
            if (!this.rulerAdsorbAreaPosition) {
                this.setRulerAdsorbPoint();

            }
        } else if (currentTarget.shapeName == this.DATA.TRIANGLE) {
            if (!this.triangleAdsorbAreaPosition) {
                this.setTriangleAdsorbPoint();
            }
        }
        console.log('mousedown');
    };

    dragMove(data) {
        data.data.originalEvent.preventDefault();
        if (data.data.originalEvent.stopPropagation) {
            data.data.originalEvent.stopPropagation();
        }
        data.data.originalEvent.cancelBubble = true;
        let currentTarget = data.currentTarget;
        if (!currentTarget.dragging)return;
        let _this = this;
        currentTarget.clicked = false;
        /* let newPosition = {x: data.data.originalEvent.pageX, y: data.data.originalEvent.pageY};*/
        let newPosition = {x: data.data.global.x, y: data.data.global.y};
        let toolPosition = {
            x: currentTarget.position.x + newPosition.x - this.startPostion.x,
            y: currentTarget.position.y + newPosition.y - this.startPostion.y
        };
        let tempW = 0;
        toolPosition.x = toolPosition.x < tempW ? tempW : toolPosition.x;
        toolPosition.x = toolPosition.x > this.DATA.CANVAS_WIDTH - tempW ? this.DATA.CANVAS_WIDTH - tempW : toolPosition.x;
        toolPosition.y = toolPosition.y < tempW ? tempW : toolPosition.y;
        toolPosition.y = toolPosition.y > this.DATA.CANVAS_HEIGHT - tempW ? this.DATA.CANVAS_HEIGHT - tempW : toolPosition.y;
        currentTarget.position.x = toolPosition.x;
        currentTarget.position.y = toolPosition.y;
        this.oneAaction.path.push([toolPosition.x, toolPosition.y]);
        if (this.startPostion.x == newPosition.x && this.startPostion.y == newPosition.y) {
            currentTarget.clicked = true;
        }
        this.startPostion = newPosition;

        if (currentTarget.shapeName == this.DATA.RULER) {
            if (currentTarget.rotation == 0) { //尺子是水平的
                this.showWordSpr = this.currentShape.widthSpr;
                setToolPosition.call(currentTarget, this.rulerAdsorbArea.top, this.rulerAdsorbAreaPosition.top, true);
                setToolPosition.call(currentTarget, this.rulerAdsorbArea.bottom, this.rulerAdsorbAreaPosition.bottom, true);
            } else if (currentTarget.rotation == this.DATA.DEGREE) {
                this.showWordSpr = this.currentShape.heightSpr;
                setToolPosition.call(currentTarget, this.rulerAdsorbArea.right, this.rulerAdsorbAreaPosition.right, true);
                setToolPosition.call(currentTarget, this.rulerAdsorbArea.left, this.rulerAdsorbAreaPosition.left, true);
            }
        } else if (currentTarget.shapeName == this.DATA.TRIANGLE) {
            this.showWordSpr = this.currentShape.rotateSpr;
            if (currentTarget.rotation == 0 || currentTarget.rotation == this.DATA.DEGREE * 4) {
                setToolPosition.call(currentTarget, this.triangleAdsorbArea.top, this.triangleAdsorbAreaPosition.top);
            } else if (currentTarget.rotation == this.DATA.DEGREE) {
                setToolPosition.call(currentTarget, this.triangleAdsorbArea.right, this.triangleAdsorbAreaPosition.right);
            } else if (currentTarget.rotation == this.DATA.DEGREE * 2) {
                setToolPosition.call(currentTarget, this.triangleAdsorbArea.bottom, this.triangleAdsorbAreaPosition.bottom);
            } else if (currentTarget.rotation == this.DATA.DEGREE * 3) {
                setToolPosition.call(currentTarget, this.triangleAdsorbArea.left, this.triangleAdsorbAreaPosition.left);
            }
        }


        function setToolPosition(area, position, flag) {
            //在吸附范围内并且没有进入过吸附区域才会发生吸附
            if (!_this.hasInAdsorbArea && this.x >= area.leftX && this.x <= area.rightX && this.y >= area.topY && this.y <= area.bottomY) {
                this.position.x = position.x;
                this.position.y = position.y;
                this.dragging = false;
                if (_this.oneAaction.path.length > 1) { //拖动事件
                    _this.hasInAdsorbArea = true;
                    _this.oldInAdsorbArea = area;
                    _this.hasAdsorbFlag = true;
                    this.clicked = false;
                    if (flag) {
                        //_this.setBigRulerPoint(position);
                    }
                }
            }

            if (_this.hasInAdsorbArea && this.dragging && (this.x < _this.oldInAdsorbArea.leftX || this.x > _this.oldInAdsorbArea.rightX || this.y < _this.oldInAdsorbArea.topY || this.y > _this.oldInAdsorbArea.bottomY)) {
                {
                    _this.hasInAdsorbArea = false;
                    _this.oldInAdsorbArea = null;
                }
            }
        }
    };

    dragEnd(data) {
        data.data.originalEvent.preventDefault();
        if (data.data.originalEvent.stopPropagation) {
            data.data.originalEvent.stopPropagation();
        }
        data.data.originalEvent.cancelBubble = true;
        let currentTarget = data.currentTarget;
        currentTarget.alpha = 0.6;
        currentTarget.dragging = false;
        currentTarget.data = null;
        this.startPostion = {};

        if (currentTarget.clicked) {
            let rotation = currentTarget.rotation;
            if (currentTarget.shapeName == this.DATA.RULER) {
                rotation = rotation == this.DATA.DEGREE ? 0 : this.DATA.DEGREE;
            } else if (currentTarget.shapeName == this.DATA.TRIANGLE) {
                rotation += this.DATA.DEGREE;
                rotation = rotation > this.DATA.DEGREE * 4 ? this.DATA.DEGREE : rotation;
            }
            currentTarget.rotation = rotation;

            this.oneAaction.action = this.DATA.ACTION.ROTATE;
            this.oneAaction.path = null;
            this.oneAaction.degree = currentTarget.rotation;
        } else {
            this.oneAaction.path.push([currentTarget.x, currentTarget.y]);
            this.oneAaction.action = this.DATA.ACTION.MOVE;
            this.oneAaction.degree = null;
        }

        if (this.hasAdsorbFlag && this.showWordSpr) {
            this.showWordSpr.alpha = 1;
        }
        this.dragActionArr.push(this.oneAaction);
        let sprName = this.showWordSpr ? this.showWordSpr.sprName : null;
        this.dragActionArr.push({action: "wait", target: this.oneAaction.target, textName: sprName});
        this.$scope.textContent.expr = JSON.stringify(this.dragActionArr);
        currentTarget.clicked = false;
        this.hasAdsorbFlag = false;
    };

    addRulerMask() {
        this.graphics = new PIXI.Graphics();
        this.rulerMask = this.graphics.beginFill("white", 0.5).drawCircle(50, this.app.renderer.height / 5, 100);
        this.rulerMask.lineColor = "white";
        this.app.stage.addChild(this.rulerMask);
        this.bigRuler.mask = this.rulerMask;
    }

    initListenerEvent(sprite) {
        sprite.alpha = 0.6;
        sprite.on('pointerdown', this.dragStart.bind(this))
            .on('pointerup', this.dragEnd.bind(this))
            .on('pointerupoutside', this.dragEnd.bind(this))
            .on('pointermove', this.dragMove.bind(this));
    };

    updateStage() {
        let _this = this;
        requestAnimationFrame(function () {
            _this.app.renderer.render(_this.app.stage);
        });
    };

    setRulerAdsorbPoint() {
        let tool = {
            w: this.ruler.width,
            w2: this.ruler.width / 2,
            h: this.ruler.height,
            h2: this.ruler.height / 2,
            h3: this.ruler.height / 3
        };
        let shape = {
            w2: this.shape.width / 2,
            h2: this.shape.height / 2
        };
        let spaceWidth = this.ruler.width / 22;

        let positionTop = {
            x: this.shape.x + tool.w2 - shape.w2 - spaceWidth,
            y: this.shape.y - shape.h2 + tool.h2 + 1
        };
        let positionRight = {
            x: this.shape.x + shape.w2 - tool.h2,
            y: this.shape.y + tool.w2 - shape.h2 - spaceWidth,
        };
        let positionBottom = {
            x: this.shape.x + tool.w2 - shape.w2 - spaceWidth,
            y: this.shape.y + shape.h2 + tool.h2
        };
        let positionLeft = {
            x: this.shape.x - shape.w2 - tool.h2,
            y: this.shape.y + tool.w2 - shape.h2 - spaceWidth,
        };

        //尺子最终停留的位置
        this.rulerAdsorbAreaPosition = {
            top: positionTop,
            right: positionRight,
            bottom: positionBottom,
            left: positionLeft,
        };

        //尺子会发生吸附的范围
        this.rulerAdsorbArea = {
            top: getTopOrBottomArea(positionTop),
            right: getLeftOrRight(positionRight),
            bottom: getTopOrBottomArea(positionBottom),
            left: getLeftOrRight(positionLeft)
        };

        function getTopOrBottomArea(position) {
            return {
                topY: position.y - tool.h3,
                bottomY: position.y + tool.h3,
                rightX: position.x + tool.h,
                leftX: position.x - tool.h
            };
        }

        function getLeftOrRight(position) {
            return {
                topY: position.y - tool.h,
                bottomY: position.y + tool.h,
                rightX: position.x + tool.h3,
                leftX: position.x - tool.h3
            };
        }

    };

    setTriangleAdsorbPoint() {
        let tool = {
            w: this.triangle.width,
            w2: this.triangle.width / 2,
            h: this.triangle.height,
            h2: this.triangle.height / 2,
            h3: this.triangle.height / 10
        };
        let shape = {
            w2: this.shape.width / 2,
            h2: this.shape.height / 2
        };
        let spaceWidth = 0;

        let positionTop = {
            x: this.shape.x + tool.w2 - shape.w2 - spaceWidth,
            y: this.shape.y - shape.h2 + tool.h2 + 1
        };
        let positionRight = {
            x: this.shape.x + shape.w2 - tool.h2,
            y: this.shape.y + tool.w2 - shape.h2 - spaceWidth,
        };
        let positionBottom = {
            x: this.shape.x - tool.w2 + shape.w2 - spaceWidth,
            y: this.shape.y - tool.h2 + shape.h2
        };
        let positionLeft = {
            x: this.shape.x + tool.h2 - shape.w2,
            y: this.shape.y - tool.w2 + shape.h2 - spaceWidth,
        };

        //三角板最终停留的位置
        this.triangleAdsorbAreaPosition = {
            top: positionTop,
            right: positionRight,
            bottom: positionBottom,
            left: positionLeft,
        };

        //三角板会发生吸附的范围
        this.triangleAdsorbArea = {
            top: getTopOrBottomArea(positionTop),
            right: getLeftOrRight(positionRight),
            bottom: getTopOrBottomArea(positionBottom),
            left: getLeftOrRight(positionLeft)
        };

        function getTopOrBottomArea(position) {
            return {
                topY: position.y - tool.h3,
                bottomY: position.y + tool.h3,
                rightX: position.x + tool.h,
                leftX: position.x - tool.h
            };
        }

        function getLeftOrRight(position) {
            return {
                topY: position.y - tool.h,
                bottomY: position.y + tool.h,
                rightX: position.x + tool.h3,
                leftX: position.x - tool.h3
            };
        }
    };

    setBigRulerPoint(position) {
        let ruler = {w: this.ruler.width, h: this.ruler.height};
        let bigRuler = {w: this.bigRuler.width, h: this.bigRuler.height};
        let shape = {w: this.shape.width, h: this.shape.height};
        let wLen = shape.w / this.DATA.SCALE.RULER * this.DATA.SCALE.BIG_RULER - shape.w;

        this.bigRuler.position.x = position.x - wLen / 2;
        this.bigRuler.position.y = position.y - ruler.h / 2 + bigRuler.h / 2;
        this.bigRuler.alpha = 0.8;
        this.bigRuler.mask = null;
        this.ruler.alpah = 0.5;
        /*  this.rulerMask.x = position.x;
         this.rulerMask.y = this.bigRuler.position.y;*/
    }

    initShape() {
        let unitLen = this.ruler.width / 11;
        let width = this.initNum((this.shape.width / unitLen).toFixed(1));
        let height = this.initNum((this.shape.height / unitLen).toFixed(1));

        let shapeName = width == height ? this.DATA.SHAPE.SQU : this.DATA.SHAPE.RECT;
        this.currentShape = {
            width: width,
            height: height,
            name: shapeName
        };
        this.initTextWord();
    };

    initNum(num) {
        let tempNum = Math.round(num);
        let n = Math.abs(tempNum - num);
        let rtn = n <= 0.2 ? tempNum : num;
        return rtn;
    };

    initTextWord() {
        let word = "";
        word = "这是一个直角";
        this.currentShape.rotateSpr = this.addText(word);
        this.currentShape.rotateSpr.sprName = "rotate";

        if (this.currentShape.name == this.DATA.SHAPE.SQU) {
            //word = this.DATA.SHAPE.SQU + "的边长是" + this.currentShape.width + "厘米";
            word = "这条边的长是" + this.currentShape.width + "厘米";
            this.currentShape.widthSpr = this.addText(word);
            this.currentShape.widthSpr.sprName = "width";
            this.currentShape.heightSpr = this.addText(word);
            this.currentShape.heightSpr.sprName = "height";
            return;
        }
        //word = this.DATA.SHAPE.RECT + "的长是" + this.currentShape.width + "厘米";
        word = "这条边的长是" + this.currentShape.width + "厘米";
        this.currentShape.widthSpr = this.addText(word);
        this.currentShape.widthSpr.sprName = "width";
        //word = this.DATA.SHAPE.RECT + "的宽是" + this.currentShape.height + "厘米";
        word = "这条边的长是" + this.currentShape.height + "厘米";
        this.currentShape.heightSpr = this.addText(word);
        this.currentShape.heightSpr.sprName = "height";
    };

    addText(word) {
        var wordSpr = new PIXI.Text(word, {
            fontFamily: 'Arial',
            fontSize: 22,
            fontWeight: 'bold',
            fill: '#424545'
        });
        wordSpr.anchor.set(0.5);
        wordSpr.y = this.ruler.y + this.ruler.height;
        wordSpr.x = this.shape.x;
        wordSpr.alpha = 0;
        this.app.stage.addChild(wordSpr);
        return wordSpr;
    }

    recordPlay() {
        if (!this.currentShape || this.currentShape && !this.currentShape.name) {
            this.initShape();
        }
        let data = JSON.parse(this.$scope.textContent.expr);
        this.pathData = {
            rulerPosition: [this.app.renderer.width / 2, this.app.renderer.height / 4],
            trianglePosition: [this.app.renderer.width / 2, this.app.renderer.height / 1.2],
            config: data,
        };


        this.recordPlayer.initPlayerData(this.pathData, this.ruler, this.triangle, this.app, this.currentShape);
        this.recordPlayer.recordPlaying();
    };

    initPlayEvent() {
        this.ruler.alpha = 0.6;
        this.triangle.alpha = 0.6;
        this.$scope.$parent.$watch("textContent.expr", this.watchAnsExpr.bind(this));
    };

    watchAnsExpr() {
        if (!this.$scope.textContent || this.$scope.textContent && !this.$scope.textContent.expr)return;
        let data = JSON.parse(this.$scope.textContent.expr);
        this.pathData = {
            rulerPosition: [this.app.renderer.width / 2, this.app.renderer.height / 5],
            trianglePosition: [this.app.renderer.width / 2, this.app.renderer.height],
            config: data,
        };

        this.btnPlay.alpha = 0.9;
        this.btnPlay.on('pointerdown', this.recordPlay.bind(this));
    }


}

OpenClass02Ctrl.$inject = [
    '$scope', 'recordPlayer'
];

export default OpenClass02Ctrl;